## ബിറ്റ്‌വൈസ് ഓപ്പറേറ്ററുകള്‍

ബിറ്റ്‌വൈസ് ഓപ്പറേറ്റര്‍ പ്രവര്‍ത്തിക്കുന്നത് ബിറ്റുകളില്‍ ആണ്. ഡാറ്റയിലെ ഓരോ ബിറ്റിനെയും കൈകാര്യം ചെയ്യാന്‍ ബിറ്റ്‌വൈസ് ഓപ്പറേറ്ററുകള്‍ ഉപയോഗിച്ച് സാധ്യമാണ്. ബിറ്റ്‌വൈസ് ഓപ്പറേറ്ററുകള്‍ ചുവടെ പട്ടികയില്‍ നല്കിയിരിക്കുന്നു.

|ഓപ്പറേറ്റര്‍ |ഓപ്പറേഷന്‍|വിവരണം|
|:----:|:-----:|:-------:|
|&|ബൈനറി ആന്‍ഡ്|ചുവടെയുള്ള ട്രൂത്ത് ടേബിളിന് അനുസൃതമായി ഓപ്പറണ്ടുകളെ കൈകാര്യം ചെയ്യുന്നു|
|\||ബൈനറി ഓര്‍|ചുവടെയുള്ള ട്രൂത്ത് ടേബിളിന് അനുസൃതമായി ഓപ്പറണ്ടുകളെ കൈകാര്യം ചെയ്യുന്നു|
|^|ബൈനറി എക്സോര്‍|ചുവടെയുള്ള ട്രൂത്ത് ടേബിളിന് അനുസൃതമായി ഓപ്പറണ്ടുകളെ കൈകാര്യം ചെയ്യുന്നു|
|~|ബൈനറി വണ്‍സ് കോംപ്ലിമെന്റ്|ചുവടെയുള്ള ട്രൂത്ത് ടേബിളിന് അനുസൃതമായി ഓപ്പറണ്ടുകളെ കൈകാര്യം ചെയ്യുന്നു|
|<<|ബൈനറി ലെഫ്റ്റ് ഷിഫ്റ്റ്|ഇടത് വശത്തെ ഓപ്പറണ്ട് വലത് വശത്തെ ഓപ്പറണ്ടില്‍ പറയുന്ന അത്രയും പ്രാവശ്യം ഇടത്തേക്ക് നീങ്ങുന്നു|
|>>|ബൈനറി റൈറ്റ് ഷിഫ്റ്റ്|ഇടത് വശത്തെ ഓപ്പറണ്ട് വലത് വശത്തെ ഓപ്പറണ്ടില്‍ പറയുന്ന അത്രയും പ്രാവശ്യം വലത്തേക്ക് നീങ്ങുന്നു|

### ബിറ്റ്‌വൈസ് ഓപ്പറേഷന്‍ ട്രൂത്ത് ടേബിള്‍

ട്രൂത്ത് ടേബിള്‍ ഓപ്പറണ്ടിലെ ഓരോ ബിറ്റും ഇന്‍പുട്ടില്‍ വരുമ്പോള്‍ എങ്ങനെ ഔട്ട്പുട്ട് വരുമെന്നു കാട്ടുന്നു. ഉദാഹരണമായി

|a|b|a&b|a\|b|a^b|
|:----:|:----:|:-----:|:-----:|:-----:|
|0|0|0|0|0|
|0|1|0|1|1|
|1|0|0|1|1|
|1|1|1|1|0|

മുകളിലെ ട്രൂത്ത് ടേബിളില്‍ a, b എന്നിവ ഇന്‍പുട്ട് ആണ്. 

|a|~a|
|:----:|:-----:|
|0|1|
|1|0|

#### ബിറ്റ്‌വൈസ് ആന്‍ഡ് ഓപ്പറേഷന്‍

$$
    \begin{array}{|c|c|c|}
    \hline
    \text{A} & \text{B} & \text{Y = A & B}\\\\
    \hline
    \text{0} & \text{0} &\color{red}{0} \\\\
    \hline
    \text{0} & \text{1} &\color{red}{0} \\\\
    \hline
    \text{1} & \text{0} &\color{red}{0} \\\\
    \hline
    \text{1} & \text{1} &\color{green}{1} \\\\
    \hline
    \end{array}
$$

```python
>>> a = 9
>>> b = 1
>>> a & b
1
```

$$
    \def\doubleunderline#1{\underline{\underline{#1}}}
    \begin{array}{ccccccc}
    \\\\
        1&0&0&\boxed{1}&*&\rightarrow &9_{10}\\\\
        0&0&0&1&&\rightarrow &1_{10} \\\\
        \hline
        0&0&0&1&&\rightarrow &1_{10} \\\\
        \hline
        \hline
    \end{array}
$$

```python
>>> a = 8
>>> b = 1
>>> a & b
0
```

$$
    \begin{array}{cccccc}
    \\\\
        1&0&0&\boxed{0}&*&\rightarrow&8_{10}\\\\
        0&0&0&1&&\rightarrow&1_{10} \\\\
        \hline
        0&0&0&0&&\rightarrow&0_{10}\\\\
        \hline
        \hline
    \end{array}
$$

**നിങ്ങള്‍ മുകളിലെ ഉദാഹരണങ്ങള്‍ ശ്രദ്ധിച്ചാല്‍ അവസാനത്തെ ബിറ്റ് ഒഴികെ മറ്റ് ബിറ്റുകള്‍ മാസ്ക് ആക്കിയിരിക്കുന്നത് കാണാം**. അവസാനത്തെ ബിറ്റ് നോക്കി സംഖ്യ ഒറ്റ സംഖ്യയാണോ ഇരട്ട സംഖ്യയാണോ എന്നു നമുക്ക് പറയാനാകും. **ഒറ്റ സംഖ്യയുടെ അവസാന ബിറ്റ് `1`-ലും ഇരട്ട സംഖ്യയുടേത് `0`-ത്തിലും ആണ് അവസാനിക്കുക.** അതായത് ഒറ്റ സംഖ്യ ആണെങ്കില്‍ \\(1_{10}\\) കൊണ്ട് മാസ്ക് ചെയ്യുമ്പോള്‍ \\(1_{10}\\) എന്നും ഇരട്ട സംഖ്യയാണെങ്കില്‍ \\(0_{10}\\) എന്നുമാകും ഔട്ട്പുട്ട് ലഭിക്കുക.

ഇത് പോലുള്ള മാസ്കിങ് ഇമേജ് പ്രോസസ്സിങ്ങിനും ഉപയോഗപ്രദമാണ്.

#### ബിറ്റ്‌വൈസ് ഓര്‍ ഓപ്പറേഷന്‍

$$
    \begin{array}{|c|c|c|}
    \hline
    \text{A} & \text{B} & \text{Y = A | B}\\\\
    \hline
    \text{0} & \text{0} &\color{red}{0} \\\\
    \hline
    \text{0} & \text{1} &\color{green}{1} \\\\
    \hline
    \text{1} & \text{0} &\color{green}{1} \\\\
    \hline
    \text{1} & \text{1} &\color{green}{1} \\\\
    \hline
    \end{array}
$$

```python
>>> a = 12
>>> b = 1
>>> a | b
13
```

$$
    \begin{array}{ccccccc}
    1&1&0&0&+&\rightarrow&12_{10} \\\\
    0&0&0&1&&\rightarrow&1_{10} \\\\
    \hline
    1&1&0&1&&\rightarrow&13_{10} \\\\
    \hline
    \hline
    \end{array}
$$

```python
>>> a = 9
>>> b = 1
>>> a | b
9
```

$$
    \begin{array}{ccccccc}
    \\\\
        1&0&1&1&+&\rightarrow&9_{10}\\\\
        1&0&1&1&&\rightarrow&1_{10} \\\\
        \hline
        1&0&1&1&&\rightarrow&9_{10} \\\\
        \hline
        \hline
    \end{array}
$$


**മറ്റ് ബിറ്റുകളെ ബാധിക്കാതെ ഒരേയൊരു ബിറ്റ് മാത്രം സെറ്റ് ചെയ്യേണ്ടുന്ന അവസരങ്ങളില്‍ ബിറ്റ്‌വൈസ് ഓര്‍ ഓപ്പറേഷന്‍ വളരെ പ്രയോജനകരമാണ്** ഉദാഹരണമായി അറ്റ്മല്‍ atmega-32 മൈക്രോകണ്ട്രോളര്‍ പരിഗണിക്കുക. ഈ മൈക്രോകണ്ട്രോളറുകളുടെ GPIO പിന്നുകള്‍  ഡാറ്റ റീഡ് ചെയ്യാനാണോ റൈറ്റ് ചെയ്യാനാണോ ഉപയോഗിക്കേണ്ടത് എന്ന് തീരുമാനിക്കുന്നത് ഡാറ്റ ഡിറക്ഷന്‍ റജിസ്റ്ററില്‍ (DDRX) സ്റ്റോര്‍ ചെയ്തിരിക്കുന്ന ബിറ്റ് 0 ആണോ 1 ആണോ എന്നുള്ളതാണ്. DDRX-ലെ ഒരു ബിറ്റ് 0 ആണെങ്കില്‍ PORTX-ലെ അതേ ബിറ്റ് (DDRX-ലെ 8-ാം ബിറ്റ് 0 ആണെങ്കില്‍ PORTX-ലെ 8-ാം ബിറ്റ്) റീഡ് (read) മോഡിലേക്കും 1 ആണെങ്കില്‍ റൈറ്റ് (write) മോഡിലേക്കും മാറും. ഉദാഹരണമായി PORT B-യിലെ എട്ടാമത്തെ ബിറ്റ് എനിക്കു ഔട്ട്പുട്ട് പോര്‍ട്ട് ആയി സെറ്റ് ചെയ്യണം എന്ന് വിചാരിക്കുക. അനങ്ങനെയെങ്കില്‍ DDRB റജിസ്റ്ററിലെ 8-ാം ബിറ്റ് `1` ആകണം. നിങ്ങള്‍ പ്രോഗ്രാം അസ്സംബ്ലി ലാംഗ്വേജില്‍ ആണ് എഴുത്തുന്നത് എങ്കില്‍ നിങ്ങള്ക്ക് റജിസ്റ്ററിലെ ഓരോ ബിറ്റും വെവ്വേറെ കൈകാര്യം ചെയ്യാനായേനെ. എന്നാല്‍ സി/ സി++/ പൈത്തണ്‍ പോലുള്ള പ്രോഗ്രാമ്മിങ് ഭാഷകള്‍ ഉപയോഗിക്കുമ്പോള്‍ നമുക്ക് ഈ ഒരു ബിറ്റ് മറ്റ് ബിറ്റുകളെ ബാധിക്കാതെ എങ്ങനെ സെറ്റ് ചെയ്യാന്‍ ആകും? ഇത് നമുക്ക് വളരെ എളുപ്പത്തില്‍ ബിറ്റ്‌വൈസ് ഓര്‍ ഓപ്പറേഷന്‍ ഉപയോഗിച്ച് സാധിയ്ക്കും. നമുക്ക് സെറ്റ് ചെയ്യേണ്ടുന്ന ബിറ്റിന്റെ അതേ സ്ഥാനത്ത് `1`-ഉം ബാക്കിയുള്ള സ്ഥാനങ്ങളില്‍ `0`-ഉം വരുന്ന ഒരു സംഖ്യ അതേ റജിസ്റ്ററുമായി/ അല്ലെങ്കില്‍ സെറ്റ് ചെയ്യേണ്ടുന്ന സംഖ്യയുമായി ബിറ്റ്‌വൈസ് ഓര്‍ ഓപ്പറേഷന്‍ നടത്തുക. ഈ ബിറ്റ്‌വൈസ് ഓര്‍ ഓപ്പറേഷന്റെ ഫലമായി ആ ബിറ്റ് സെറ്റ് ആകുകയും മറ്റ് ബിറ്റുകള്‍ക്ക് വിത്യാസം ഒന്നും വരികയുമില്ല. ഉദാഹരണമായി DDRB-യിലെ മറ്റ് ബിറ്റുകള്‍ക്ക് വിത്യാസം വരാതെ 8-ാമത്തെ മാത്രം ബിറ്റ് സെറ്റ് ചെയ്യണം എങ്കില്‍ DDRB-യുമായി 0b0000 0001 ബിറ്റ്‌വൈസ് ഓര്‍ ചെയ്താല്‍ മതിയാകും. നമുക്ക് DDRB-യിലെ മറ്റ് ബിറ്റുകള്‍ എന്താണെന്ന് ചിന്തിക്കേണ്ട ആവശ്യമില്ല.

$$
    \begin{array}{cc|ccccccccccc}
        \text{DDRB of AVR MCU} &\rightarrow&?&?&?&?&?&?&?&?&+&\rightarrow&?\\\\
        \text{OR DDRB with } 1_{10} &\rightarrow&0&0&0&0&0&0&0&1&&\rightarrow &1_{10} \\\\
        \hline
        \text{Now DDRB}&\rightarrow&?&?&?&?&?&?&?&1&&& \\\\
        \hline
        \hline
        \text{Then PORTB becomes }&\rightarrow & ?&?&?&?&?&?&?&1&&\rightarrow& 1_{10}
    \end{array} 
$$

ഇത് PORT B-യിലെ PIN0 ഓണ്‍ ആക്കും. DDRB-യിലെ ബിറ്റ് തുടക്കത്തില്‍ എന്താണെന്ന് പ്രോഗ്രമ്മാറിന് അറിയില്ല... ചിലപ്പോള്‍ അത് 0 ആകാം അല്ലെങ്കില്‍ 1 ആകാം. ഈ ഒരു അനിശ്ചിതത്വം ഉള്ളതിനാല്‍ ആണ് ഞാന്‍ ബിറ്റുകള്‍ക്ക് `?` കൊടുത്തിരിക്കുന്നത്. 

**ഉറപ്പായും ഈ ഓപ്പറേഷനും ഇമേജ് പ്രോസസ്സിങ് എന്‍ക്രിപ്ഷന്‍ അല്‍ഗോരിതങ്ങള്‍ തുടങ്ങിയവയില്‍ ഉപയോഗിച്ച് പോരുന്നതാണ്.**

### ബിറ്റ്‌വൈസ് എക്സോര്‍ ഓപ്പറേഷന്‍

$$
    \begin{array}{|c|c|c|}
    \hline
    \text{A} & \text{B} & \text{Y} \\\\
    \hline
    \text{0} & \text{0} & \color{red}{0} \\\\
    \hline
    \text{0} & \text{1} & \color{green}{1} \\\\
    \hline
    \text{1} & \text{0} & \color{green}{1} \\\\
    \hline
    \text{1} & \text{1} & \color{red}{0} \\\\
    \hline
    \end{array}
$$

```python
>>> a = 11
>>> b = 11
>>> a ^ b
0
```

$$
    \begin{array}{ccccccc}
        1&0&1&1&\oplus&\rightarrow& 11_{10} \\\\
        1&0&1&1&&\rightarrow& 11_{10} \\\\
        \hline
        0&0&0&0&&\rightarrow& 0_{10}\\\\
        \hline
        \hline
    \end{array}
$$

* **സൈക്ലിക് റെഡന്‍ഡന്‍സി ചെക്ക് (CRC), പാരിറ്റി ചെക്കിങ് തുടങ്ങിയവയ്ക്കു ഉപയോഗിക്കാം.** ഒരേ ഡാറ്റ എക്സോര്‍ ചെയ്താല്‍ \\(0_{10}\\) ആയിരിയ്ക്കും ഔട്ട്പുട്ട് കിട്ടുക എന്നുള്ളതിനാല്‍ ഇലക്ട്രോണിക്സിന്റെ വീക്ഷണ കോണില്‍ ആണെങ്കില്‍ ഏറ്റവും കുറവ് ഇന്‍സ്ട്രക്ഷനുകളുടെ സഹായത്തോടെ മറ്റ് വേരിയബിളുകളുടെ സഹായം ഇല്ലാതെ ഒരു റജിസ്റ്റര്‍ ക്ലിയര്‍ ചെയ്യാന്‍ ബിറ്റ്‌വൈസ് എക്സോര്‍ ഉപയോഗപ്പെടും.


## സീറോ പാഡഡ് ലെഫ്റ്റ് ഷിഫ്റ്റ്/ റൈറ്റ് ഷിഫ്റ്റ്

$$
    \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    2^{7} = 128&2^{6} = 64&2^{5} = 32&2^{4} = 16&2^{3} = 8&2^{2} = 4&2^{1} = 2&2^{0} = 1\\\\
    \hline
    \color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{green}1&\rightarrow&1_{10}\\\\
    \hline
    \color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{green}{1}&\color{red}0& \rightarrow&2_{10}\\\\
    \hline
    \color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{green}1&\color{red}0&\color{red}0& \rightarrow&4_{10}\\\\
    \hline
    \color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{green}1&\color{red}0&\color{red}0&\color{red}0& \rightarrow&8_{10}\\\\
    \hline
    \color{red}0&\color{red}0&\color{red}0&\color{green}1&\color{red}0&\color{red}0&\color{red}0&\color{red}0& \rightarrow&16_{10}\\\\
    \hline
    \color{red}0&\color{red}0&\color{green}1&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0& \rightarrow&32_{10}\\\\
    \hline
    \color{red}0&\color{green}1&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0& \rightarrow&64_{10}\\\\
    \hline
    \color{green}1&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0&\color{red}0& \rightarrow&128_{10}\\\\
    \hline
    \end{array}
$$

```python
>>> a = 128
>>> a >> 1
64
>>> a >> 2
32
>>> a >> 3
16
>>> a << 1
256
>>> a << 2
512
>>> a << 3
1024
```

* വലതു വശത്തേക്ക് സീറോ പാഡ് ചെയ്തു ഓരോ പ്രാവശ്യവും ഷിഫ്റ്റ് ചെയ്യുമ്പോള്‍ 2 കൊണ്ട് ഹരിക്കുന്നതിന് തുല്യമാണ്.
* ഇടതു വശത്തേക്ക് സീറോ പാഡ് ചെയ്തു ഓരോ പ്രാവശ്യവും ഷിഫ്റ്റ് ചെയ്യുമ്പോള്‍ 2 കൊണ്ട് ഗുണിക്കുന്നതിന് തുല്യമാണ്.

## ബിറ്റ്‌വൈസ് നോട്ട് ഓപ്പറേഷന്‍

* ബിറ്റ്‌വൈസ് നോട്ട് ഓപ്പറേഷന്‍ കുറച്ചു തൊന്തരവായ ഒരു ഓപ്പറേഷന്‍ ആണ്.
* സാധാരണ ഗതിയില്‍ നോട്ട് ഓപ്പറേഷന്‍ ബിറ്റ് ഇന്‍വെര്‍ട് ചെയ്യുകയാണ് സാധാരണ ഗതിയില്‍ ചെയ്യുന്നത്.


$$
    \begin{array}{|c|c|}
        \hline
        \text{A} & \text{Y}\\\\
        \hline
        0 & \color{red}{1}\\\\
        \hline
        1 & \color{green}{0}\\\\
        \hline     
    \end{array}
$$

നോട്ട് ഓപ്പറേഷന്‍ ബിറ്റ് ഇന്‍വെര്‍ട് ചെയ്യുകയാണ് ചെയ്യുന്നത് എങ്കില്‍ ചുവടെയുള്ള രീതിയില്‍ ആണ് ഔട്ട്പുട്ട് കിട്ടേണ്ടത്. 

$$
    \begin{array}{ccc}
    \overline{0001_{2}}&\rightarrow& 1110_{2}&\\\\
    \downarrow&&\downarrow\\\\
    \text{1}&&\text{14}
    \end{array}
$$

എന്നാല്‍ നമുക്ക് എല്ലാ പ്രോഗ്രാമ്മിങ് ഭാഷകളിലും കിട്ടുന്ന ഔട്ട്പുട്ട് ചുവടെ കാണുന്നത് പോലെ വളരെ വ്യത്യസ്തമാണ്

```python
>>> a = 1
>>> ~a
-2
```

$\overline{1} = -2$ ???? 🤔

എന്താണ് ഇതിന് പിന്നിലെ കാരണം എന്ന് അനുബന്ധത്തില്‍ ചര്‍ച്ച ചെയ്യുന്നതാണ്.

