### ഐഡന്റിഫയര്‍ (Identifier)

ഐഡന്റിഫയറുകള്‍ എന്നാല്‍ വേരിയബിള്‍, ഫംഗ്ഷന്‍, ക്ലാസ്, മൊഡ്യൂള്‍, ഒബ്ജെക്ടുകള്‍ തുടങ്ങിയവയ്ക്ക് പ്രോഗ്രാമ്മര്‍ നല്‍കുന്ന പേരാണ്. പൈത്തണ്‍ കേസ് സെന്‍സിറ്റീവ് (case sensitive) ആണ്. അതായത് ഇംഗ്ലിഷ് അക്ഷരമാലയിലെ ചെറിയക്ഷരങ്ങളെയും (Lower case letter) വലിയക്ഷരങ്ങളെയും (Upper Case Letter) വ്യത്യസ്ഥമായ അക്ഷരങ്ങള്‍ ആയാണ് പൈത്തണ്‍ കണക്കാക്കുന്നത്. ഐഡന്റിഫയറുകള്‍ ചുവടെപ്പറയുന്ന നിയമങ്ങള്‍ അനുസരിക്കണം:

1. ഐഡന്റിഫയറുകളില്‍ ചെറിയക്ഷരങ്ങളോ ([a-z]) വലിയക്ഷരങ്ങളോ ([A-Z]) അണ്ടര്‍സ്കോറോ (_) അക്കങ്ങളോ (0-9) ആണ് ഉപയോഗിക്കാവൂ. total എന്നുള്ളതും Total എന്നുള്ളതും രണ്ട് വ്യത്യസ്ഥങ്ങളായ ഐഡന്റിഫയര്‍ ആണെന്ന് ഓര്‍മിക്കുമല്ലോ.
2. പൈത്തണ്‍ നീക്കിവെച്ചിരിക്കുന്ന കീവേഡുകള്‍ ഐഡന്റിഫയര്‍ ആയി ഉപയോഗിക്കരുത് (കീവേഡുകള്‍ തൊട്ടടുത്ത ഭാഗത്ത് തന്നെ ചര്‍ച്ച ചെയ്യുന്നുണ്ട്).
3. ഐഡന്റിഫയര്‍ അക്കങ്ങളില്‍ തുടങ്ങരുത്. ഉദാഹരമായി `2times` എന്നുള്ളത് അസാധുവായ ഒരു ഐഡന്റിഫയര്‍ ആണ്.
4. @, !, #, $, %, ^, എന്നിങ്ങനെയുള്ള ചിഹ്നങ്ങള്‍ ഐഡന്റിഫയറില്‍ ഉപയോഗിക്കരുത്. ഉദാഹരണമായി #total എന്നുള്ളത് അസാധുവായ ഒരു ഐഡന്റിഫയര്‍ ആണ്.
5. ഐഡന്റിഫയറിന് എത്ര നീളവും ആകാം.

> ആദ്യം പറഞ്ഞിരിക്കുന്ന നിയമത്തില്‍ ഒരു തിരുത്ത് ഉണ്ട്. ഇംഗ്ലിഷ് ബുക്കുകള്‍ ആണ് വിപണിയില്‍ ലഭ്യം. അതിനാല്‍ ആണ് മിക്കവാറും ബുക്കുകളില്‍ ഐഡന്റിഫയര്‍ ഇങ്ങനെയാകണം എന്നൊരു ലിഖിതമായ നിയമം നിലനില്‍ക്കുന്നത്. എന്നാല്‍ സത്യമെന്തെന്നാല്‍ നമുക്ക് യൂണീക്കോഡില്‍ എഴുതപ്പെട്ട ഏത് അക്ഷരവും വാക്കുകളും പൈത്തണ്‍ ഐഡന്റിഫയര്‍ ആയി ഉപയോഗിക്കാം. ഉദാഹരണമായി ചുവടെയുള്ള കോഡ് ശ്രദ്ധിയ്ക്കുക. മലയാളം വാക്കുകള്‍ ചുവടെ ഐഡന്റിഫയര്‍ ആയി ഉപയോഗിച്ചിരിക്കുന്നത് നിങ്ങള്‍ക്ക് കാണാന്‍ ആകുന്നതാണ്. നിങ്ങള്‍ക്ക് പ്രതീക്ഷിച്ച ഔട്ട്പുട്ട് ചുവടെയുള്ള പ്രോഗ്രാമ്മില്‍ നിന്നും ലഭിക്കുന്നുണ്ട് എന്ന് നിങ്ങള്‍ക്ക് വിലയിരുത്താവുന്നതാണ് (ഈയൊരു കാര്യം വിലയിരുത്തുന്നതിന് മുമ്പ് ടെര്‍മിനല്‍/ കമാന്‍ഡ് പ്രോംപ്റ്റ്/ കോഡ് എഡിറ്റര്‍/ ഐ‌.ഡി‌.എല്‍.‌ഇ തുടങ്ങിയവ മലയാളം യൂണീക്കോഡ് പിന്തുണയുള്ള ഒരു ഫോണ്ടിലേക്ക് മാറ്റുന്നത് നന്നായിരിക്കും.). 

```python
പച്ച_മാങ്ങ = 10
പഴുത്ത_മാങ്ങ = 20

ആകെ_മാങ്ങ = പച്ച_മാങ്ങ + പഴുത്ത_മാങ്ങ

print(ആകെ_മാങ്ങ)
```

**പൈത്തണ്‍ ഐഡന്റിഫയറുകളുടെ പേരില്‍ ലോകത്താകെയുള്ള പ്രോഗ്രാമ്മര്‍മാര്‍ പിന്തുടരുന്ന കുറച്ചു ആചാരങ്ങള്‍ (conventions) ഉണ്ട്. അത് ചുവടെ ചര്‍ച്ച ചെയ്യുന്നു:**

* ക്ലാസ്സിന്റെ പേര്‍ ഇംഗ്ലിഷ് വലിയക്ഷരത്തില്‍ തുടങ്ങണം. മറ്റെല്ലാ ഐഡന്റിഫയറുകളുടെയും പേരിനായി ഇംഗ്ലിഷിലെ ചെറിയക്ഷരങ്ങള്‍ ഉപയോഗിക്കണം.
* ഐഡന്റിഫയര്‍ തുടങ്ങുന്നത് ഒറ്റ അണ്ടര്‍സ്കോറില്‍ ആണെങ്കില്‍ അത് പ്രൈവറ്റ് ആണ്. ഉദാഹരണമായി _data.
* ഐഡന്റിഫയര്‍ തുടങ്ങുന്നത് രണ്ട് അണ്ടര്‍സ്കോറില്‍ ആണെങ്കില്‍ അത് സ്ട്രോങ്‌ലി പ്രൈവറ്റ് ആണ്. ഉദാഹരണമായി __protected_data.
* ഒരു ഐഡന്റിഫയറിന്റെ തുടക്കത്തിലും ഒടുക്കത്തിലും രണ്ട് അണ്ടര്‍സ്കോര്‍ ഉണ്ടെങ്കില്‍ അത് പൈത്തണ്‍ സ്വന്തം പ്രവര്‍ത്തനങ്ങള്‍ക്കായി നീക്കിവെച്ചിരിക്കുന്ന ഐഡന്റിഫയര്‍ ആയിരിയ്ക്കും. ഉദാഹരണം `__init__`.

### കീവേഡുകള്‍ (Keywords)

* പ്രോഗ്രാമ്മിങ് ഭാഷകളില്‍ അതാതിന് മാത്രം ഉപയോഗിക്കാനായി നീക്കിവെച്ചിരിക്കുന്ന പ്രോഗ്രാമ്മറിന് ഐഡന്റിഫയര്‍ ഉപയോഗിക്കാനാവാത്ത ചില പദങ്ങളാണ് കീവേഡുകള്‍. പൈത്തണ്‍ 3.9-ല്‍ 36 കീവേര്‍ഡുകള്‍ ഉണ്ട്. പൈത്തണിലെ കീവേര്‍ഡുകള്‍ കാണുവാനായി:

```python
>>> import keyword
>>> keyword.kwlist
['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
>>> len(keyword.kwlist)
36
```
മുകളിലെ ഓരോ കീവേര്‍ഡും നമ്മള്‍ വിശദമായി ഈയൊരു പുസ്തകത്തിന്റെ പല ഭാഗങ്ങളിലായി ചര്‍ച്ച ചെയ്യുന്നതാണ്. ചുവടെയുള്ള പട്ടികയിലും കീവേഡുകള്‍ നല്കിയിട്ടുണ്ട്.

||||||||
|:---:|:----:|:----:|:----:|:----:|:----:|:----:|
|False|None|True|`__peg_parser__`|and|as|assert|
|async|await|break|class|continue|def|del|
|elif|else|except|finally|for|from|global|
|if|import|in|is|lambda|nonlocal|not|
|or|pass|raise|return|try|while|with|
|yield|||||||


### വേരിയബിള്‍

നമ്മള്‍ പ്രോഗ്രാമ്മില്‍ ഉപയോഗിയ്ക്കുന്ന എല്ലാ വിവരങ്ങളും ഒബ്ജെക്ടുകളും നമ്മുടെ കംപ്യൂട്ടറിന്റെ റാമില്‍ ആയിരിയ്ക്കും സൂക്ഷിക്കപ്പെടുന്നത്. റാമിലേ ഈ ഡാറ്റ കൈകാര്യം ചെയ്യണം എങ്കില്‍ നമുക്ക് ഡാറ്റ സൂക്ഷിക്കപ്പെടുന്ന മെമ്മറി ലൊക്കേഷന്‍റെ അഡ്രസ്സ് അറിഞ്ഞിരിക്കണം. ഈ അഡ്രസ്സ് ഒരു പ്രോഗ്രാമ്മറിനെ സംബദ്ധിച്ച് ഓര്‍ത്തിരിക്കേണ്ടുന്ന ആവശ്യമില്ല. അപ്പോള്‍ മെമ്മറി ലൊക്കേഷന്റെ ഈ അഡ്രസ്സിന് പകരം പ്രോഗ്രാമില്‍ പ്രോഗ്രാമ്മാറിന് എളുപ്പത്തില്‍ ഓര്‍മയില്‍ സൂക്ഷിക്കാന്‍ പറ്റുന്ന പേരുകള്‍ അഥവാ ഐഡന്റിഫയറുകള്‍ ഉപയോഗിക്കാം. ഇങ്ങനെ മെമ്മറി അഡ്രസ്സിന് പകരം ഉപയോഗിയ്ക്കുന്ന പേരുകള്‍ ആണ് വേരിയബിളുകള്‍.

* പൈത്തണിലെ വേരിയബിളുകള്‍ നിങ്ങള്‍ രാവിലെ ചായ കുടിക്കുന്ന കപ്പ് പോലെയാണ്. നിങ്ങള്‍ക്ക് കുറച്ചു കഴിയുമ്പോള്‍ ആ കപ്പില്‍ കഞ്ഞിവെള്ളം കുടിക്കാം, പിന്നീട് ജ്യൂസ് കുടിക്കാം, കല്ല് നിറക്കാം 😜. അതായത് പൈത്തണ്‍ വേരിയബിളില്‍ നിങ്ങള്‍ക്ക് എന്ത് വേണമെങ്കിലും സംഭരിക്കാം. പൈത്തണ്‍ വേരിയബിളില്‍ നമുക്ക് ഏത് ഡാറ്റടൈപ്പ് വേണമെങ്കിലും സംഭരിക്കാം. എന്താണ് ഞാന്‍ ഇങ്ങനെ പറയാന്‍ കാരണം എന്ന് കൂടുതല്‍ വ്യക്തമായി നിങ്ങള്‍ക്ക് വഴിയേ മനസ്സിലാകും.

#### വേരിയബിള്‍ അസ്സൈന്‍മെന്റ്

പൈത്തണില്‍ വേരിയബിള്‍ അസ്സൈന്‍ ചെയ്യുന്നത് ചുവടെക്കാണുന്ന രീതിയില്‍ ആണ്:

```python
>>>num = 10
```

* ഇവിടെ `num` എന്നതാണ് വേരിയബിള്‍. num പോയിന്റ് ചെയ്യുന്നത് ഒരു മെമ്മറി ലൊക്കേഷനിലേക്ക് ആയിരിയ്ക്കും. ഈ മെമ്മറി ലൊക്കേഷന്‍ കാണുവാന്‍ നിങ്ങള്‍ക്ക് `id` എന്ന ബില്‍റ്റിന്‍ ഫംഗ്ഷന്‍ ഉപയോഗിക്കാവുന്നതാണ്.

```python
>>>id(num)
2314464488016
>>>
```

* ഇവിടെ `=` എന്നത് ഗണിതത്തില്‍ പരിചിതമായ സമം ആണെന്ന് തെറ്റിദ്ധരിക്കരുത്. ഇത് വലതു വശത്തുള്ള 10 എന്ന വാല്യൂ ഇടതു വശത്തെ `num` എന്ന വേരിയബിളിലേക്ക് ആരോപിക്കുകയാണ് (assign) ചെയ്യുന്നത്.


### കമെന്റ്

നമ്മള്‍ ഇന്നെഴുതുന്ന പ്രോഗ്രാം വളരെ നാളുകള്‍ക്ക് ശേഷം നോക്കുമ്പോള്‍ നമ്മള്‍ എന്ത് ഉദ്ദേശത്തിലാണ് എഴുതിയത് എന്ന് മനസ്സിലാക്കുക പ്രയാസമായിരിക്കും. ഈയൊരു പ്രശ്നം പരിഹരിക്കുകയാണ് പ്രോഗ്രാമ്മിലെ കമെന്റിന്റെ പ്രാഥമിക ലക്ഷ്യം. നമ്മള്‍ എഴുതുന്ന പ്രോഗ്രാമ്മില്‍ നമുക്ക് ഓരോ ലൈനും എന്ത് ഉദ്ദേശത്തിലാണ് എഴുതിയതെന്ന് പ്രോഗ്രാമ്മിന്റെ കൂടെ തന്നെ നമുക്ക് എഴുതാം. ഇങ്ങനെ എഴുതുന്ന കമെന്റുകള്‍ പൈത്തണ്‍ ഇന്റര്‍പ്രെട്ടര്‍ റീഡ് ചെയ്യുന്നത് ഒഴിവാക്കുന്നതിനാല്‍ കമെന്റുകള്‍ പ്രോഗ്രാമ്മിന്റെ പ്രവര്‍ത്തനത്തെ യാതൊരു തരത്തിലും ബാധിക്കില്ല. പൈത്തണില്‍ കമെന്റ് ആയി എഴുതുന്ന ഓരോ വരിക്കും മുന്നില്‍ `#` ചിഹ്നം കൊടുക്കേണ്ടതാണ്.

```python
# here sum is initialized to zero
sum = 0
```

* പ്രോഗ്രാമ്മാറിന് പ്രോഗ്രാമ്മിലെ ലൈനുകള്‍ എക്സിക്യൂട്ട് ചെയ്യേണ്ടുന്ന ആവശ്യം ഇല്ല എന്നു തോന്നുന്ന പക്ഷം ആ ഒരു ലൈനിന്റെ മുമ്പില്‍ `#` ഇട്ടുകൊണ്ട് ആ ലൈന്‍ എക്സിക്യൂട്ട് ചെയ്യുന്നത് ഒഴിവാക്കാവുന്നതാണ്.

### ഡോക്സ്ട്രിംഗ്

ഒന്നിലധികം ലൈനുകളില്‍ ആയി കമെന്റ് എഴുതേണ്ട സാഹചര്യങ്ങളില്‍, അതായത് ഒരു ഫംഗ്ഷനെപ്പറ്റിയോ ക്ലാസ്സിനെപ്പറ്റിയോ വിപുലമായ ഒരു നോട്ട് എഴുതേണ്ടുന്ന സാഹചര്യത്തില്‍ ആണ്‍ ഡോക്സ്ട്രിംഗ് ഉപയോഗിക്കുന്നത്. ചുവടെയുള്ള കോഡില്‍ മൂന്ന് ഉദ്ധരണികള്‍ക്ക് (""") ഉള്ളില്‍ എഴുതിയിരിക്കുന്നതാണ് ഡോക്സ്ട്രിംഗ്.

```python
def square(num, ret=True):
    """
    The input parameters of function is `num` and `ret`.
    The `ret` is by default `True`. If `ret` is `True` function returns
    the square of number. Otherwise it will print out on console
    """
    if ret:
        return num ** 2
    print(f"{num}^2 = {num ** 2}")


square(5)
square(5, ret=False)
```

ഡോക്സ്ട്രിംഗ് എഴുത്തുന്നതിന്റെ പ്രധാന മെച്ചം കോഡ് എഡിറ്റര്‍ അല്ലെങ്കില്‍ ഐ.‌ഡി‌.എല്‍.‌ഇ-കളില്‍ (IDLE) നമ്മള്‍ എഴുതിയ ഫംഗ്ഷന് മുകളില്‍ മൌസ് ഹോവര്‍ ചെയ്യുമ്പോള്‍ ഈയൊരു ഡോക്സ്ട്രിംഗ് കാണാന്‍ ആകും (ചവടെയുള്ള ചിത്രം നിരീക്ഷിക്കുക). ഈയൊരു കാര്യം നമ്മള്‍ എഴുതിയ കോഡ് മറ്റുള്ളവര്‍ നോക്കുമ്പോള്‍ അവര്‍ക്ക് ആ ഒരു ഫംഗ്ഷനെക്കുറിച്ച് വളരെ എളുപ്പത്തില്‍ മനസ്സിലാക്കാന്‍ പ്രയോജനപ്പെടും.

![ഡോക്സ്ട്രിംഗ്](/chapter_1/images/docstring.png)

കൂടാതെ `help` ഫംഗ്ഷന്റെ സഹായത്തോടെ ഇന്ററാക്ടീവ് ഇന്റര്‍പ്രെട്ടറില്‍ നമുക്ക് ഈ ഫങ്ഷന്‍റെ ഡോക്യുമെന്റേഷന്‍ ചുവടെ നല്കിയിരിക്കുന്നത് പോലെ കാണാവുന്നതാണ്.

```python
F:\MyPythonBook\PythonPointsToPonder>python
Python 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> from test import square
5^2 = 25
>>> help(square)
Help on function square in module test:

square(num, ret=True)
    The input parameters of function is `num` and `ret`.
    The `ret` is by default `True`. If `ret` is `True` function returns
    the square of number. Otherwise it will print out on console

>>>
```