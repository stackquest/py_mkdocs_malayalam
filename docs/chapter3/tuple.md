ലിസ്റ്റില്‍ നിന്നു വിപരീതമായി വ്യത്യസ്ഥാമായ ഡാറ്റാസ്ട്രക്ചറിലുള്ള ഡാറ്റ(heterogeneous data) സ്റ്റോര്‍ ചെയ്യുവാന്‍ ടപ്പിള്‍ ഉപയോഗിക്കുക എന്നുള്ളതാണ് പരക്കെയുള്ള സമ്പ്രദായം. എന്നാല്‍ നിങ്ങള്‍ക്ക് ടപ്പിളില്‍ ഒരേ ഡാറ്റാസ്ട്രക്ചറിലുള്ള ഡാറ്റ (homogeneous data) സ്റ്റോര്‍ ചെയ്യുന്നതിനും തടസ്സമൊന്നും ഇല്ല.

??? warning
	ശൂന്യമായ ടപ്പിള്‍ ഇനീഷ്യലൈസ് ചെയ്യാന്‍ `()` പരാന്തെസിസ് ഉപയോഗിയ്ക്കുകയോ `tuple()` എന്ന കണ്‍സ്ട്രക്ടര്‍ ഉപയോഗിയ്ക്കുകയോ ചുവടെ കാണുന്നത് പോലെ ചെയ്യാമെങ്കിലും ശൂന്യമായ  ടപ്പിള്‍ പിന്നീട് പ്രയോജനം ഒന്നും ചെയ്യില്ല. കാരണം ടപ്പിള്‍ ഒരു ഇമ്മ്യൂട്ടബിള്‍ ഡാറ്റാസ്ട്രക്ചര്‍ ആയതിനാല്‍ തന്നെ ശൂന്യമായ ടപ്പിളിലേക്ക് പിന്നീട് ഡാറ്റ നിറയ്ക്കാന്‍ പറ്റില്ല.
    ```python
	>>> a = ()
	>>> type(a)
	<class 'tuple'>
	>>> b = tuple()
	>>> type(b)
	<class 'tuple'>
    ```

പൈത്തണ്‍ ടപ്പിള്‍ ഇനീഷ്യലൈസ് ചെയ്യുവാനായി നമുക്ക് ചുവടെക്കാണുന്ന രണ്ട് മാര്‍ഗങ്ങള്‍ ഉപയോഗിക്കാം.

1. പരാന്തെസിസ് ഉപയോഗിച്ച്:
```python
>>> t1 = (1, 2, 3.2, 'hello')
>>> t1
(1, 2, 3.2, 'hello')
```
2. പരാന്തെസിസ് ഉപയോഗിക്കാതെ:
```python
>>> t2 = 1, 2, 3.2, 'hello'
>>> t2
(1, 2, 3.2, 'hello')
```

???+ success

	### ടപ്പിള്‍/ലിസ്റ്റ് അണ്‍പാക്കിങ്
	
    ```python
    >>> num1, num2 = 3, 5
    >>> num1
    3
    >>> num2
    5
    ```
    മുകളില്‍ വലതു കൈപ്പുറത്ത് (RHS) നമ്മള്‍ എഴുതിയിരിക്കുന്നത് ഒരു ടപ്പിള്‍ ആണ്. ആ ടപ്പിള്‍ ഇടത് വശത്തെ വേരിയബിളുകളിലേക്ക് യദാക്രമം അണ്‍പാക്ക് ചെയ്യപ്പെടുന്നു; num1 എന്ന വേരിയബിള്‍ 3-ഉം num2 എന്ന വേരിയബിള്‍ 5-ഉം മൂല്യം കൈവരിക്കുന്നു.
    ```python
    >>> num1, num2 = (3, 5)
    >>> num1
    3
    >>> num2
    5
    ```
    മുകളിലെ ഉദാഹരണത്തില്‍ ടപ്പിള്‍ കുറച്ചു കൂടെ വ്യക്തമായി പരാന്തെസിസില്‍ എഴുതി എന്നു മാത്രം.
    ```python
    >>> num1, num2 = [3, 5]
    >>> num1
    3
    >>> num2
    5
    ```
    ടപ്പിള്‍ ആണ്‍പാക്കിങ് പോലെ തന്നെ ലിസ്റ്റും വേരിയബിലേക്ക് ഡാറ്റ അണ്‍പാക്ക് ചെയ്യാനായി ഉപയോഗിക്കാം എന്ന് കാട്ടാന്‍ വേണ്ടിയാണ് മുകളിലെ ഉദാഹരണം ഉപയോഗിച്ചത്.

???+ warning

	ടപ്പിള്‍ അണ്‍പാക്കിങ് ഉപയോഗിക്കുമ്പോള്‍ നിങ്ങള്‍ ചിന്തിച്ചിരിക്കാം ഒരു ഐറ്റം മാത്രമുള്ള ടപ്പിള്‍ എങ്ങനെ എഴുതും എന്ന്:

    ```python
    >>> t1 = (1)
    >>> t1
    1
    ```
    മുകളില്‍ കാട്ടിയിരിക്കുന്ന രീതിയില്‍ ഒരു ഐറ്റം മാത്രമുള്ള ടപ്പിള്‍ ഇനീഷ്യലൈസ് ചെയ്താല്‍ ടപ്പിള്‍ അണ്‍പാക്കിങ് നടക്കുന്നതിനാല്‍ t1 എന്ന വേരിയബിള്‍ ഇന്റീജര്‍ ആയി മാറും. ടപ്പിളിന്റെ ഈയൊരു സ്വഭാവ വ്യതിയാനം ടപ്പിള്‍ ഡിക്ലേര്‍ ചെയ്യുമ്പോള്‍ അറിഞ്ഞിരിക്കേണ്ടത് അത്യാവശ്യമാണ്. ഈയൊരു പ്രശ്നം നമുക്ക് ചുവടെ കാണുന്ന രീതിയില്‍ ഒരു കോമ്മ കൂടെ പരാന്തെസിസില്‍ കൂടുതലായി ഇട്ട് പരിഹരിക്കാവുന്നതാണ്.
    ```python
    >>> t2 = (1,)
    >>> t2
    (1,)
    ```

## ഇന്‍ഡെക്സിങ്

ലിസ്റ്റ് നമുക്ക് ലിസ്റ്റ് പോലെ തന്നെ ടപ്പിള്‍ ഇന്‍ഡെക്സ് ചെയ്യാവുന്നതാണ്. മുന്നില്‍ നിന്നാണെങ്കില്‍ 0-ല്‍ നിന്നും വാലറ്റത്തു നിന്നാണെങ്കില്‍ -1-ല്‍ നിന്നും ടപ്പിള്‍ ഇന്‍ഡെക്സ് ചെയ്യാവുന്നതാണ്.

```python
>>> numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
>>> numbers[0]
1
>>> numbers[2]
3
>>> numbers[3]
4
>>> numbers[-1]
10
>>> numbers[-3]
8
```

![img](/chapter3/images/tuple_indexing.png)

## സ്ലൈസിങ് (Slicing)

```
>>> numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
>>> numbers[1:5]
(2, 3, 4, 5)
>>> numbers[:5]
(1, 2, 3, 4, 5)
>>> numbers[2:]
(3, 4, 5, 6, 7, 8, 9, 10)
>>> numbers[::2]
[1, 3, 5, 7, 9]
>>> numbers[::-1]
(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
>>> numbers[::3]
(1, 4, 7, 10)
```

## ടപ്പിള്‍ അസൈന്‍മെന്റ്

**ടപ്പിള്‍ ഇമ്മ്യൂട്ടബിള്‍ ആയ ഒരു ഡാറ്റാസ്ട്രക്ചര്‍ ആണ്**.

```python
>>> t1 = 1, 2, 3, 4, 5
>>> t1[0] = 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

അതിനാല്‍ തന്നെ ടപ്പിളിലെ നിലവിലുള്ള ഐറ്റത്തിന് വ്യത്യാസം വരുത്താന്‍ ആകില്ല. അങ്ങനെ ചെയ്യാന്‍ ശ്രമിച്ചാല്‍ മുകളിലേത് പോലെ ഒരു TypeError-ല്‍ (`TypeError: 'tuple' object does not support item assignment`) ആകും കലാശിക്കുക.

## ടപ്പിള്‍ കോംപ്രഹെന്‍ഷന്‍

ടപ്പിള്‍ ഉപയോഗിച്ചും നമുക്ക് ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ പോലെ തന്നെ എഴുതാനാകും. എന്നാല്‍ ടപ്പിള്‍ കോംപ്രഹെന്‍ഷന്‍ എഴുതുമ്പോള്‍ നമുക്ക് ഒരു ജനറേറ്റര്‍ എക്സ്പ്രെഷന്‍ (Generator Expression) ആണ് കിട്ടുക. ജനറേറ്റര്‍ (Generator) എന്താണെന്ന് നമുക്ക് മറ്റൊരു ഭാഗത്ത് ചര്‍ച്ച ചെയ്യാം.

ഉദാഹരണമായി 0 മുതല്‍ 10 വരെയുള്ള സംഖ്യകളുടെ സ്ക്വയര്‍ കാണാനുള്ള ടപ്പിള്‍ കോംപ്രഹെന്‍ഷന്‍ ചുവടെക്കാണുന്ന രീതിയില്‍ എഴുതാവുന്നതാണ്.

```python
>>> (i ** 2 for i in range(0, 11))
<generator object <genexpr> at 0x7fa39ddfee40> # (1)
```

1. :man_raising_hand: ഒരു `<genexpr>` അഥവാ ജനറേറ്റര്‍ ഒബ്ജക്റ്റ് മെമ്മറിയില്‍ ഉണ്ടായി എന്നാണ് ഇത് സൂചിപ്പിക്കുന്നത്.

മുകളില്‍ ഉള്ള ജനറേറ്റര്‍ ഒബ്ജക്റ്റ് നമുക്ക് `*` അഥവാ ആസ്റ്ററിക് ഉപയോഗിച്ച് ചുവടെക്കാണുന്ന രീതിയില്‍ അണ്‍പാക്ക് ചെയ്യാവുന്നതാണ്.

```python
>>> t1 = (i ** 2 for i in range(0, 11))
>>> print(*t1) # (1)
0 1 4 9 16 25 36 49 64 81 100
```

1. :man_raising_hand: `>>>*t1` എന്നു നമുക്ക് ഇന്റര്‍പ്രെറ്ററില്‍ എഴുതാന്‍ ആകില്ല. കാരണം `*` എന്ന ഓപ്പറേറ്റര്‍ ഒരു ഫംഗ്ഷനിലേക്ക് ആര്‍ഗുമെന്റ്സ് നല്‍കുവാനായാണ് ഉപയോഗിക്കുന്നത്. ഇവിടെ ആ ഫംഗ്ഷന്‍ `print` എന്ന ബില്‍ട്ട്-ഇന്‍ ഫംഗ്ഷന്‍ ആണ്.

നമുക്ക് മുകളിലെ `*` ഓപ്പറേറ്ററിനെക്കാള്‍ എളുപ്പത്തില്‍ ഉപയോഗിക്കാനാകുന്ന ഒരു രീതിയാണ് ചുവടെ നല്കിയിരിക്കുന്നത്. `tuple` എന്ന കണ്‍സ്ട്രക്റ്ററിലേക്ക് നമ്മള്‍ നിര്‍മിച്ച ജനറേറ്റര്‍ എക്സ്പ്രെഷന്‍ പാസ്സ് ചെയ്യുക.

```python
>>> t1 = (i ** 2 for i in range(0, 11))
>>> print(tuple(t1))
(0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
```
