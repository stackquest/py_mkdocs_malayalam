പൈത്തണ്‍ പിന്തുണയ്ക്കുന്ന ന്യൂമെറിക്കല്‍ ഡാറ്റടൈപ്പുകള്‍ ചുവടെ നല്കിയിരിക്കുന്നു:

1. int
2. float
3. complex

* പൈത്തണില്‍ ഇന്റീജറുകളുടെ ലെങ്ത് എത്ര വേണമെങ്കിലും ആകാം. ഇന്റീജറുകളുടെ ലെങ്തിന് പരിധി കല്‍പ്പിക്കപ്പെടുന്നത് മെമ്മറി കുറവുള്ള സാഹചര്യങ്ങളില്‍ മാത്രമാണ്.
* പൈത്തണില്‍ ഫ്ലോട്ടിങ് പോയിന്റ് നമ്പറുകള്‍ പ്രതിനിധീകരിച്ചിരിക്കുന്നത് IEEE 754 സ്റ്റാന്‍ഡേര്‍ഡ് അനുസരിച്ചാണ്.
* ഫ്ലോട്ടിങ് പോയിന്റ് നമ്പറുകള്‍ 17 ദശാംശ സ്ഥാനങ്ങള്‍ വരെ കൃത്യത ഉള്ളതാണ്.
* കോംപ്ലെക്സ് നമ്പറുകള്‍ എഴുത്തുന്നത് $x+yj$ എന്ന രീതിയില്‍ ആണ്. ഇവിടെ $x$ റിയല്‍ പാര്‍ട്ടും $y$ ഇമാജിനറി പാര്‍ട്ടും ആണ്.

```python
a = 1
>>> b = 1.5
>>> c = 2 + 9j
>>> print(f"{a=}")
a=1
>>> print(f"{b=}")
b=1.5
>>> print(f"{c=}") 
c=(2+9j)
```

???+ note

	#### ഇന്റേര്‍ണിങ്

    ഇമ്മ്യൂട്ടബിള്‍ ആയ ഒബ്ജെക്ടുകള്‍ക്ക് ഒരേ മൂല്യമാണ് മെമ്മറിയില്‍ സൂക്ഷിക്കുന്നത് എങ്കില്‍ പുതിയ ഒബ്ജെക്ടുകള്‍ മെമ്മറിയില്‍ നിര്‍മിക്കുന്നതിന് പകരം മുന്‍പേ നിര്‍മിക്കപ്പെട്ട ഒബ്ജെക്ടുകള്‍ പുനരുപയോഗിക്കുന്നതിനെയാണ് ഇന്റേര്‍ണിങ് എന്നു പറയുന്നതു. 


???+ info

    #### ഇന്റീജര്‍ ഇന്റേര്‍ണിങ്

    പൈത്തണില്‍ -5 മുതല്‍ 256 വരെയുള്ള ഇന്റീജര്‍ സംഖ്യകള്‍ ഇന്റേര്‍ണിങ് ചെയ്തിരിക്കുന്നു. നമ്മള്‍ പൈത്തണിലെ എല്ലാം തന്നെ ഒബ്ജെക്ടുകള്‍ ആണെന്ന് പറഞ്ഞിരുന്നു. നമ്മള്‍ `a = 5` എന്നു വേരിയബിള്‍ അസ്സൈന്‍ ചെയ്യുമ്പോള്‍ പുതിയ ഒരു ഇന്റീജര്‍ ഒബ്ജക്റ്റ് കമ്പ്യൂട്ടറിന്റെ റാമില്‍ നിര്‍മിക്കപ്പെടുകയാണ് ചെയ്യുന്നത്. ഓരോ പ്രാവശ്യവും പുതിയ ഒബ്ജെക്ടുകള്‍ നിര്‍മിക്കുന്നത് കൂടുതല്‍ മെമ്മറി ഉപയോഗത്തിന് വഴി വെക്കുന്നു. അതിനാല്‍ തന്നെ നമ്മള്‍ പുതുതായി `b = 5` എന്ന പുതിയ ഒരു വേരിയബിള്‍ നിര്‍മിക്കുമ്പോള്‍ ഇവിടെ മുന്‍പേ `a` എന്ന വേരിയബിളിലേക്ക് അസ്സൈന്‍ ചെയ്യപ്പെട്ട മൂല്യം 5 ആയതിനാല്‍ വീണ്ടും ഒരിക്കല്‍ കൂടെ പുതിയ ഒരു ഒബ്ജക്റ്റ് നിര്‍മിക്കപ്പെടേണ്ടത് ഇല്ലല്ലോ. ആ ഒരു മൂല്യം മെമ്മറിയില്‍ മുന്‍പേയുള്ളതിനാല്‍ പൈത്തണ്‍ `b` എന്ന വേരിയബിളിനെ 5 സ്റ്റോര്‍ ചെയ്തിരിക്കുന്ന മെമറി ലൊക്കേഷനിലേക്ക് പോയിന്റ് ചെയ്യുകയായിരിക്കും ചെയ്യുക. അതിനാല്‍ തന്നെ വീണ്ടും പുതിയ ഒരു ഒബ്ജക്റ്റ് മെമ്മറിയില്‍ നിര്‍മിക്കപ്പെടുകയോ മെമ്മറി നഷ്ടം ഉണ്ടാവുകയോ ചെയ്യുന്നില്ല.

???+ danger

    #### ഇന്റേര്‍ണിങും പ്രശ്നങ്ങളും

    ഇന്റേര്‍ണിങ് പല സമയങ്ങളിലും വ്യത്യസ്ഥമായ സ്വഭാവങ്ങള്‍ കാട്ടുന്നു എന്നുള്ളത് ശ്രദ്ധയോടെ നോക്കി കാണേണ്ടതാണ്.

    1. പൈത്തണ്‍ ഇന്റര്‍പ്രെട്ടറില്‍ ഇന്റീജറിന്റെ സ്വഭാവം
    **ചുവടെ id എന്ന ബില്‍ട്ട്-ഇന്‍ ഫംഗ്ഷന്‍ തിരികെ നല്‍കുന്നത് ഒബ്ജെക്ടുകള്‍ സ്റ്റോര്‍ ചെയ്തിരിക്കുന്ന മെമ്മറി ലൊക്കേഷന്‍ ഏതാണെന്നാണ്.**
    ```python
    >>> a = -5
    >>> b = -5
    >>> id(a), id(b)
    (139964221778032, 139964221778032)
    >>> a is b
    True
    ```
    മുകളില്‍ `a`-യും `b`-യും സ്റ്റോര്‍ ചെയ്തിരിക്കുന്നത് ഒരേ മെമ്മറി ലൊക്കേഷനില്‍ ആണെന്ന് കാണാം. അതിനാല്‍ തന്നെയാണ് ഐഡെന്റിറ്റി ഓപ്പറേറ്റര്‍ ആയ `is` True തിരികെ നല്കിയിരിക്കുന്നത്.
    ```python
	>>> a = -6
    >>> b = -6
    >>> id(a), id(b)
    (139964220293776, 139964220293808)
    >>> a is b
    False
    ```
    മുകളില്‍ `a`-യും `b`-യും സ്റ്റോര്‍ ചെയ്തിരിക്കുന്നത് വ്യത്യസ്ഥ മെമ്മറി ലൊക്കേഷനില്‍ ആണെന്ന് കാണാം. അതിനാല്‍ തന്നെയാണ് ഐഡെന്റിറ്റി ഓപ്പറേറ്റര്‍ ആയ `is` False തിരികെ നല്കിയിരിക്കുന്നത്. നമ്മള്‍ -5 മുതല്‍ -256 വരെയുള്ള ഇന്‍റീജറുകള്‍ ആണ് ഇന്റേര്‍ണിങിന് വിധേയമായിട്ടുള്ളൂ എന്നു പറഞ്ഞത് ഓര്‍ക്കുമല്ലോ... ഇവിടെ a-യും b-യും സ്റ്റോര്‍ ചെയ്തിരിക്കുന്നത് [-5, 256] എന്ന പരിധിക്ക് വെളിയിലുള്ള സംഖ്യ ആയതിനാല്‍ ആണ് a, b എന്നീ ഒബ്ജെക്ടുകള്‍ ഇന്റേര്‍ണിങിന് വിധേയമാകാത്തത്.
    ```python
    >>> a = 256
    >>> b = 256
    >>> id(a), id(b)
    (139964221974928, 139964221974928)
    >>> a is b
    True
    >>> a = 257
    >>> b = 257
    >>> id(a), id(b)
    (139964220294160, 139964220293808)
    >>> a is b
    False
    ```
    മുകളില്‍ ഉള്ള ഉദാഹരണത്തില്‍ ഒബ്ജെക്ടുകളുടെ ഇന്റേര്‍ണിങ് എങ്ങനെ എന്നു ഇനി സ്വയം വിലയിരുത്താമല്ലോ കൂട്ടുകാര്‍ക്ക്.

    2. പൈത്തണ്‍ സ്ക്രിപ്റ്റില്‍ ഇന്റീജറിന്റെ സ്വഭാവം
    ചുവടെയുള്ള പൈത്തണ്‍ സ്ക്രിപ്റ്റ് ശ്രദ്ധിയ്ക്കുക:
    ```python
	a = -5
	b = -5
	
	print(f"{id(a)=}, {id(b)=}")
	print(f"{a is b =}")
	
	c = -6
	d = -6
	
	print(f"{id(c)=}, {id(c)=}")
	print(f"{c is d =}")
    ```
    ഈ സ്ക്രിപ്റ്റിന്റെ ഔട്ട്പുട്ട് ചുവടെ നല്കിയിരിക്കുന്നു:
	```bash
	id(a)=140514126882928, id(b)=140514126882928
	a is b =True
	id(c)=140514126462736, id(c)=140514126462736
	c is d =True
    ```
    ആദ്യത്തെ ഉദാഹരണത്തില്‍ a-യുടെയും b-യുടെയും മൂല്യം -6 ആയിരുന്നപ്പോള്‍ `a`-യും `b`-യും സ്റ്റോര്‍ ചെയ്തിരുന്നത് വെവ്വേറെ മെമ്മറി ലൊക്കേഷനുകളില്‍ ആയിരുന്നു. എന്നാല്‍ ഇവിടെ `c`-യും `d`-യും സ്റ്റോര്‍ ചെയ്തിരിക്കുന്നത് ഒരേ മെമ്മറി ലൊക്കേഷനില്‍ ആണെന്ന് കാണാം. അതെങ്ങനെ സംഭവിച്ചു? ഇങ്ങനെ സംഭവിക്കാന്‍ കാരണം പൈത്തണ്‍ സ്ക്രിപ്റ്റ് ഇന്റര്‍പ്രെട്ട് ചെയ്യുന്നതിന് മുമ്പ് ബൈറ്റ് കോഡിലേക്ക് കംപൈല്‍ ചെയ്യപ്പെടുന്നുണ്ട്. ഇങ്ങനെ കംപൈല്‍ ചെയ്യുന്ന സമയത്ത് പൈത്തണ്‍ ബൈറ്റ് കോഡ് കംപൈലറിന് ഒരേ സമയം `c` എന്ന വേരിയബിളും `d` എന്ന വേരിയബിളും ഒരേ മൂല്യമാണ് സ്റ്റോര്‍ ചെയ്യുന്നതെന്ന് മനസ്സിലാക്കാനും ഒരേ മൂല്യം സ്റ്റോര്‍ ചെയ്യാനായി കൂടുതല്‍ മെമ്മറി ലൊക്കേഷനുകള്‍ ഉപയോഗിക്കുന്നത് തടഞ്ഞുകൊണ്ട് മെമ്മറി ഒപ്റ്റിമൈസേഷന്‍ ചെയ്യാനും സാധിയ്ക്കും.
    ഇനി നമുക്ക് മറ്റൊരുദാഹരണം നോക്കാം:
    ```python
    def ret_a(x):
    return x - 2

    def ret_b(x):
        return x - 1

    a = ret_a(-4)
    b = ret_b(-5)
    print(f"{id(a) = } and {id(b) = }")
    print(f"{a is b = }")
    ``` 
    മുകളിലെ സ്ക്രിപ്റ്റിന്റെ ഔട്പുട് ചുവടെ നല്കിയിരിക്കുന്നു:
    ```bash
    id(a) = 140271368657840 and id(b) = 140271368657456
    a is b = False
    ```
    മുകളില്‍ -4 - 2 = -6 എന്നുള്ളതാണ് `a` എന്ന വേരിയബിളിലേക്ക് `ret_a` എന്ന ഫംഗ്ഷനില്‍ നിന്നും റിട്ടേണ്‍ ചെയ്യുന്നത്. കൂടാതെ -5 - 1 = -6 എന്നുള്ളതാണ് `b` എന്ന വേരിയബിളിലേക്ക് `ret_b` എന്ന ഫംഗ്ഷനില്‍ നിന്നും റിട്ടേണ്‍ ചെയ്യുന്നത്. തൊട്ട് മുമ്പത്തെ ഉദാഹരണത്തില്‍ നിന്ന് വിഭിന്നമായി `a` എന്ന വേരിയബിളിന്റെയും `b` എന്ന വേരിയബിളിന്റെയും മൂല്യം ഒന്നായിട്ട് (-6) കൂടെ നമുക്ക് `a is b` എന്നുള്ളത് False ആണ് ലഭിച്ചതു. അതിന്റെ കാരണം പൈത്തണ്‍ ബൈറ്റ് കോഡ് കംപൈലറിന് ഇപ്പോള്‍ `a`-യുടെയും `b`-യുടെയും മൂല്യം 2 ഫംഗ്ഷനെ ആശ്രയിച്ചായതിനാല്‍ ഒരേ സമയം തിട്ടപ്പെടുത്താനാവില്ല. അതിനാല്‍ത്തന്നെ നമ്മള്‍ `is` എന്ന ഐഡെന്റിറ്റി ഓപ്പറേറ്റര്‍ ശ്രദ്ധാപൂര്‍വം വേണം ഉപയോഗിക്കാന്‍.  
