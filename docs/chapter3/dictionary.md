പൈത്തണിലെ ഒരു **മാപ്പിങ് ടൈപ്പ്** ആണ് ഡിക്ഷനറി. നിങ്ങള്‍ക്ക് php സുപരിചിതമാണെങ്കില്‍ php-യിലെ അസ്സോസിയേറ്റീവ് അറേയുടെ (associative array) ആശയം തന്നെയാണ് ഡിക്ഷനറിയും. ലിസ്റ്റ്, ടപ്പിള്‍ തുടങ്ങിയ ഡാറ്റാ സ്ട്രക്ചറുകള്‍ ഒരു ശ്രേണി സൂക്ഷിക്കാനും കൈകാര്യം ചെയ്യാനുമാണ് ശ്രമിച്ചിരുന്നത്. എന്നാല്‍ ഡിക്ഷനറി കൈകാര്യം ചെയ്യാന്‍ ശ്രമിക്കുന്നത് അര്‍ഥവത്തായ ഡാറ്റ ആണ്. അങ്ങനെ പറയുവാന്‍ കാരണം ഡിക്ഷനറിയില്‍ ഡാറ്റ സൂക്ഷിക്കുന്നത് ഒരു കീ-വാല്യൂ ജോഡിയായാണ് (key-value pair). കീ (key) ഡാറ്റയെക്കുറിച്ച് നമുക്ക് ആശയം തരുമ്പോള്‍ വാല്യൂ അതിന്റെ മൂല്യമെന്താണെന്ന് പറയുന്നു.

ഉദാഹരണമായി ചുവടെയുള്ള സ്നിപ്പറ്റ് ശ്രദ്ധിയ്ക്കുക:

```python
>>> color1 = (255, 0, 0)
>>> color2 = [255, 0, 0]
```

ഇവിടെ `color1` എന്ന വേരിയബിള്‍ ടപ്പിളും `color2` എന്ന വേരിയബിള്‍ ലിസ്റ്റും ആണ്. പക്ഷേ നമ്മള്‍ ടപ്പിള്‍ ആയി കളര്‍ എഴുതിയാലും ലിസ്റ്റ് ആയി കളര്‍ എഴുതിയാലും അനുവാചകന് സംശയം ബാക്കിയാവും, എഴുതിയ ആള്‍ RGB ഫോര്‍മാറ്റില്‍ ആണോ കളര്‍ എഴുതിയത്, BGR ഫോര്‍മാറ്റില്‍ ആണോ അതോ മറ്റേതെങ്കിലും ഫോര്‍മാറ്റ് ആണോ ഉദ്ദേശിക്കുന്നത് എന്നു? :thinking_face:

ഡിക്ഷനറി ഉപയോഗിക്കുകയാണെങ്കില്‍ ഈയൊരു സംശയത്തിന് സ്ഥാനം ഇല്ല. ഡിക്ഷനറി `{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'...}` ഈയൊരു ഫോര്‍മാറ്റില്‍ ഡാറ്റ സൂക്ഷിക്കുന്നതിനാല്‍ അനുവാചകന്റെ സംശയം ദൂരീകരിക്കപ്പെടും.

```python
>>> color = {
...     "red": 255,
...     "green": 0,
...     "blue": 0
... }
```

എന്ന രീതിയില്‍ `color` എന്ന വേരിയബിള്‍ ഉപയോഗിച്ചാല്‍ ഇത് RGB കളറിനെക്കുറിച്ചാണ് പറയുന്നതു എന്നും നിറം ചുവപ്പാണ് (red) ആണെന്ന് വളരെ വ്യക്തമാകുന്നു.

???+ note
	ഡിക്ഷനറിയുടെ `key` ആയി ഇമ്മ്യൂട്ടബിള്‍ ആയ ഒബ്ജക്റ്റ് ആണ് ഉപയോഗിക്കാന്‍ ആകൂ. അതേ സമയം ഈ ഇമ്മ്യൂട്ടബിള്‍ ഒബ്ജക്റ്റ് ഹാഷബിളും (hash) ആയിരിക്കണം. ഉദാഹരണമായി സ്ട്രിംഗ്, ഇന്റീജര്‍ തുടങ്ങിയവ ഇമ്മ്യൂട്ടബിള്‍ ആണ് അതേ സമയം ഹാഷബിളും ആണ്. പൈത്തണിലെ ഒരു ഒബ്ജക്റ്റ് ഹാഷബിള്‍ ആണോ എന്ന് നമുക്ക് എളുപ്പത്തില്‍ ചുവടെക്കാണുന്ന രീതിയില്‍ കണ്ടെത്താവുന്നതാണ്.

    ```python
    >>> n = 1
    >>> dir(n)
    ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__',
    '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__',
    '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__',
    '__getnewargs__', '__gt__', '__hash__', # (1)!
    '__index__', '__init__',
    '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__',
    '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__',
    '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__',
    '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',
    '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__',
    '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__',
    '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio',
    'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator',
    'real', 'to_bytes']
    ```

    1. :man_raising_hand: ഹാഷ് മാജിക് മെത്തേഡ്

    dir ഫംഗ്ഷന്‍ ഉപയോഗിച്ച് ആട്രിബ്യൂട്ടുകള്‍ പരിശോധിക്കുമ്പോള്‍ `__hash__` എന്ന മെത്തേഡ് കണ്ടെത്താനായാല്‍ ആ ഒബ്ജക്റ്റ് ഹാഷബിള്‍ ആണ്.

    കാര്യങ്ങള്‍ കുറച്ച് കൂടെ താഴെക്കാണുന്ന കോഡ് `True` ആണോ തിരികെ നല്‍കുന്നത് എന്നു നോക്കിയാലും മതി. `False` ആണ് തിരികെ നല്‍കുന്നത് എങ്കില്‍ ഒബ്ജക്റ്റ് ഹാഷബിള്‍ അല്ല എന്നും മനസ്സിലാക്കണം.

    ```python
    >>> '__hash__' in dir(n)
	True
    ```

ലിസ്റ്റിലേത് പോലെ സ്ലൈസിങ്, സ്ലൈസ് അസൈന്‍മെന്റ് തുടങ്ങിയ ഓപ്പറേഷനുകള്‍ ഡിക്ഷനറിയില്‍ സാധ്യമല്ല.

## ഇന്‍ഡെക്സിങ്

ഡിക്ഷനറിയിലെ ഒരു വാല്യൂ ലഭിക്കാന്‍ `dict[key]` എന്ന സിന്റാക്സ് ഉപയോഗിക്കാവുന്നതാണ്. ഉദാഹരണമായി:

```python
>>> color = {
...     "red": 255,
...     "green": 0,
...     "blue": 0
... }
>>> color['red']
255
```

