ലിസ്റ്റ് എന്ന് പറയുന്നത് ഒരു ഡൈനാമിക് അറേ ആണ്. വ്യത്യസ്തങ്ങളായ (heterogeneous) ഡാറ്റാടൈപ്പുകള്‍ സൂക്ഷിക്കാന്‍ ലിസ്റ്റ് ഉപയോഗിക്കാമെങ്കിലും ഒരേ ഡാറ്റാടൈപ്പിലുള്ള (homogeneous) ഡാറ്റ സൂക്ഷിക്കാന്‍ ലിസ്റ്റ് ഉപയോഗിക്കുക എന്നുള്ളതാണ് പരക്കെയുള്ള സമ്പ്രദായം.
 
???+ danger
	
    സി പോലുള്ള പ്രോഗ്രാമ്മിങ് ഭാഷകള്‍ നിങ്ങള്‍ക്ക് പരിചിതമാണെങ്കില്‍, അവിടെ അറേയില്‍ ഒരു ഡാറ്റാടൈപ്പ് മാത്രമേ സ്റ്റോര്‍ ചെയ്യാനാകൂ. കൂടാതെ അറേയുടെ സൈസ് സ്തിരമായിരിക്കും അഥവാ അറേയ്ക്കായി ഒരു നിശ്ചിത മെമ്മറി അറേ ഇനീഷ്യലൈസ് ചെയ്യുമ്പോള്‍ തന്നെ നീക്കിവെച്ചിട്ടുണ്ടാകും. എന്നാല്‍ പൈത്തണില്‍ അറേയ്ക്കു പകരമായി ഉപയോഗിയ്ക്കുന്ന ലിസ്റ്റിന്റെ സൈസ് സ്ഥിരമല്ല (not fixed). കൂടാതെ ഒന്നിലധികം ഡാറ്റാടൈപ്പുകള്‍ ലിസ്റ്റില്‍ സൂക്ഷിക്കാനാകും. അതിനാല്‍ ലിസ്റ്റ് ഉപയോഗിക്കുമ്പോള്‍ മെമ്മറി ഉപയോഗം കൂടുന്നതിനെപ്പറ്റി ഒരു ശ്രദ്ധ ഉണ്ടാകേണ്ടതാണ്.

ശൂന്യമായ ലിസ്റ്റ് താഴെക്കാണുന്ന രണ്ട് രീതിയില്‍ ഇനീഷ്യലൈസ് ചെയ്യാവുന്നതാണ്:

1. `[]` ബ്രാക്കറ്റുകള്‍ക്കുള്ളില്‍ ആണ് ലിസ്റ്റ് എഴുതാറുള്ളത്. കൂടാതെ ലിസ്റ്റിലെ ഓരോ ഐറ്റവും `,` കോമ ഉപയോഗിച്ചാണ് വേര്‍തിരിക്കുന്നത്.  അതിനാല്‍ ശൂന്യമായ ബ്രാക്കറ്റുകള്‍ ലിസ്റ്റ് ഇനീഷ്യലൈസ് ചെയ്യുവാനായി ഉപയോഗിക്കാവുന്നതാണ്.
```python
>>> a = []
>>> type(a)
<class 'list'>
```
2. `list()` എന്ന കന്‍സ്ട്രക്ടര്‍ ഉപയോഗിച്ചും നമുക്ക് ലിസ്റ്റ് ചുവടെക്കാണുന്നത് പോലെ ഇനീഷ്യലൈസ് ചെയ്യാവുന്നതാണ്. എന്നാല്‍ ആദ്യത്തെ രീതിയാണ് കുറച്ചുകൂടെ പാരായണക്ഷമത വര്‍ദ്ധിപ്പിക്കുന്നത്.
```python
>>> b = list()
>>> type(b)
<class 'list'>
```

## ഇന്‍ഡെക്സിങ് (indexing)

ലിസ്റ്റ് നമുക്ക് സ്ട്രിംഗ് പോലെ തന്നെ ലിസ്റ്റ് ഇന്‍ഡെക്സ് ചെയ്യാവുന്നതാണ്. മുന്നില്‍ നിന്നാണെങ്കില്‍ 0-ല്‍ നിന്നും വാലറ്റത്തു നിന്നാണെങ്കില്‍ -1-ല്‍ നിന്നും ലിസ്റ്റ് ഇന്‍ഡെക്സ് ചെയ്യാവുന്നതാണ്.

```python
>>> numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[0]
1
>>> numbers[2]
3
>>> numbers[3]
4
>>> numbers[-1]
10
>>> numbers[-3]
8
```

![img](/chapter3/images/list_indexing.png)

## സ്ലൈസിങ് (Slicing)

നമുക്ക് ലിസ്റ്റ് ഇന്‍ഡെക്സിങ് ഉപയോഗിച്ച് ലിസ്റ്റ് യഥേഷ്ടം മുറിക്കാവുന്നതാണ് അല്ലെങ്കില്‍ slice ചെയ്യാവുന്നതാണ്. slice ചെയ്യുമ്പോള്‍ പാലിക്കേണ്ട സിന്റാക്സ്    `lst[start, stop, <step>]` എന്നതാണ്. ഇവിടെ `lst` എന്നുള്ളത് slice ചെയ്യപ്പെടേണ്ട വേരിയബിള്‍ ആണ്, `start` എന്നത് ഏത് ഇന്‍ഡെക്സില്‍ നിന്നും slice ചെയ്യാന്‍ ആരംഭിക്കണം എന്നുള്ളതും, `stop` എന്നുള്ളത് ഏത് ഇന്‍ഡെക്സില്‍ slice ചെയ്യുന്നത് അവസാനിപ്പിക്കണം എന്നുള്ളതും, `<step>` എന്നുള്ളത് `start` നിന്നും എത്ര ഇടവിട്ടാണ് `stop` വരെ എത്തേണ്ടത് എന്നുള്ളതുമാണ്. ഇവിടെ stop-നു ഒരു സ്ഥാനം മുമ്പ് `(stop_index - 1)` slice ചെയ്യുന്നത് നില്‍ക്കും. കൂടാതെ ഇവിടെ `<step>` എന്നുള്ളത് ഐച്ഛികമാണ് (ഉപയോഗിക്കണം എന്നു നിര്‍ബന്ധമില്ല).

1-ാമത്തെ ഇന്‍ഡെക്സ് മുതല്‍ 5-ാമത്തെ ഇന്‍ഡെക്സ് വരെയുള്ള ലിസ്റ്റിലെ ഐറ്റം slice ചെയ്യാന്‍ ചുവടെക്കാണുന്ന രീതി ഉപയോഗിക്കാം.
```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[1:5]
[2, 3, 4, 5]
```

![img](/chapter3/images/list_slicing_1.png)

ആദ്യത്തെ ഇന്‍ഡെക്സ് മുതല്‍ 5-ാമത്തെ ഇന്‍ഡെക്സ് വരെയുള്ള ലിസ്റ്റിലെ ഐറ്റം slice ചെയ്യാന്‍ ചുവടെക്കാണുന്ന രീതി ഉപയോഗിക്കാം. ഇവിടെ `start` ആര്‍ഗുമെന്റ് നല്‍കിയിട്ടില്ല അഥവാ ശൂന്യമാണ്. അതിനാല്‍ ഇവിടെ ഡീഫോള്‍ട്ട് ആയി ആദ്യത്തെ ഐറ്റത്തില്‍ നിന്നും സ്ലൈസ് ചെയ്യാന്‍ ആരംഭിക്കും.

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[:5]
[1, 2, 3, 4, 5]
```

![img](/chapter3/images/list_slicing_2.png)

2-ാമത്തെ ഇന്‍ഡെക്സ് മുതല്‍ അവസാന ഇന്‍ഡെക്സ് വരെ സ്ലൈസ് ചെയ്യുന്നതെങ്ങനെയെന്നാണ് ചുവടെ നല്കിയിരിക്കുന്നത്. ഇവിടെ സ്ലൈസ് ചെയ്യാനുള്ള സിന്റാക്സില്‍ `stop` ആര്‍ഗുമെന്റ് ശൂന്യമാണ്. അതിനാല്‍ തന്നെ അവസാന ഇന്‍ഡെക്സ് വരെ പൈത്തണ്‍ ഇവിടെ ലിസ്റ്റ് സ്ലൈസ് ചെയ്യും.

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[2:]
[3, 4, 5, 6, 7, 8, 9, 10]
```

![img](/chapter3/images/list_slicing_3.png)

എന്നാല്‍ ചുവടെ `start`, `stop` എന്നീ ആര്‍ഗുമെന്റുകള്‍ ഇല്ല, എന്നാല്‍ `step` എന്ന ആര്‍ഗുമെന്റ് ഇവിടെ 2 ആണെന്ന് കാണാം. `start` `stop` എന്നിവ ഇല്ലാത്തതിനാല്‍ പൈത്തണ്‍ ലിസ്റ്റ് ആദ്യം മുതല്‍ അവസാനം വരെ എടുക്കുകയും `step` 2 ആയതിനാല്‍ ഒന്നിടവിട്ട ഐറ്റം മാത്രം ഔട്ട്പുട്ട് തരികയും ചെയ്യും.

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[::2]
[1, 3, 5, 7, 9]
```

![img](/chapter3/images/list_slicing_4.png)

എന്നാല്‍ ചുവടെ `start`, `stop` എന്നീ ആര്‍ഗുമെന്റുകള്‍ ഇല്ല, എന്നാല്‍ `step` എന്ന ആര്‍ഗുമെന്റ് ഇവിടെ 2 ആണെന്ന് കാണാം. `start` `stop` എന്നിവ ഇല്ലാത്തതിനാല്‍ പൈത്തണ്‍ ലിസ്റ്റ് ആദ്യം മുതല്‍ അവസാനം വരെ എടുക്കുകയും `step` -1 ആയതിനാല്‍ ലിസ്റ്റിലെ ഐറ്റങ്ങളുടെ ഓര്‍ഡര്‍ പുറകോട്ടേക്ക് തിരിച്ച് (reverse order) ഔട്ട്പുട്ട് നല്കുകയും ചെയ്യുന്നു. 

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[::-1]
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

![img](/chapter3/images/list_slicing_5.png)

എന്നാല്‍ ചുവടെ `start`, `stop` എന്നീ ആര്‍ഗുമെന്റുകള്‍ ഇല്ല, എന്നാല്‍ `step` എന്ന ആര്‍ഗുമെന്റ് ഇവിടെ 3 ആണെന്ന് കാണാം. `start` `stop` എന്നിവ ഇല്ലാത്തതിനാല്‍ പൈത്തണ്‍ ലിസ്റ്റ് ആദ്യം മുതല്‍ അവസാനം വരെ എടുക്കുകയും `step` 3 ആയതിനാല്‍ ലിസ്റ്റിലെ ഓരോ രണ്ടിടവിട്ട ഐറ്റങ്ങളും തിരികെ നല്‍കുകയും ചെയ്യുന്നു. 

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[::3]
[1, 4, 7, 10]
```

![img](/chapter3/images/list_slicing_6.png)

## ലിസ്റ്റ് അസൈന്‍മെന്റ്

**ലിസ്റ്റ് മ്യൂട്ടബിള്‍ ആയ ഒരു ഡാറ്റാസ്ട്രക്ചര്‍ ആണ്**. അതിനാല്‍ തന്നെ നമുക്ക് ലിസ്റ്റിലെ ഓരോ ഐറ്റത്തിനും പുതിയ മൂല്യം ചുവടെക്കാണുന്നത് പോലെ ആരോപിക്കാവുന്നതാണ്.

```python
>>> numbers = [1, 2, 3, 4]
>>> numbers[0] = 0
>>> numbers
[0, 2, 3, 4]
```

![img](/chapter3/images/list_assignment_1.png)

## സ്ലൈസെഡ് അസൈന്‍മെന്റ് (Sliced Assignment)

ചുവടെ `l1` എന്ന ലിസ്റ്റ് ശ്രദ്ധിയ്ക്കുക. അതില്‍ 0 മുതല്‍ 4 വരെയുള്ള എണ്ണല്‍ സംഖ്യകള്‍ കാണാം. ഇതിലെ 1-ാമത്തെ ഐറ്റം മുതല്‍ 3-ാമത്തെ ഐറ്റം വരെ സ്ലൈസ് ചെയ്താല്‍ നമുക്ക് ലഭിക്കുന്നത് [1, 2] ആണ്.

```python
>>> l1 = [0, 1, 2, 3, 4]
>>> l1[1:3]
[1, 2]
```

ഈ സ്ലൈസ് ചെയ്ത ഐറ്റത്തിന് പകരം പുതിയ [5, 6] എന്നീ എലെമെന്റുകള്‍ പകരം വെക്കണമെങ്കില്‍ ചുവടെക്കാണുന്ന രീതിയില്‍ എളുപ്പത്തില്‍ അത് ചെയ്യാവുന്നതാണ്.

```python
>>> l1[1:3] = [5, 6]
>>> l1
[0, 5, 6, 3, 4]
```

## ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍

പുതിയ ഒരു ലിസ്റ്റ് എളുപ്പത്തില്‍ നിര്‍മിക്കാനോ ഉള്ള ഒരു ലിസ്റ്റില്‍ (മറ്റൊരു ഡാറ്റാസ്ട്രക്ചറില്‍ നിന്നും കഴിയും) നിന്നും പുതിയ ഒരു ലിസ്റ്റ് നിര്‍മിക്കുവാന്‍ ആണ് ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിക്കുക. ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്റെ സിന്റാക്സ് ചുവടെക്കാണുന്ന രീതിയില്‍ ആണ്:
```python
[expression for item in iterable <condition>]
```

മുകളിലെ സിന്റാക്സില്‍ `<condition>` ഐച്ഛികമാണ്. ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ എങ്ങനെ ഉപയോഗിക്കാം എന്നു നമുക്ക് നോക്കാം:

1. പൂജ്യം മുതല്‍ 9 വരെയുള്ള സംഖ്യകള്‍ അടങ്ങുന്ന ലിസ്റ്റ് നമുക്ക് ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിച്ച് ചുവടെക്കാണുന്ന രീതിയില്‍ നിര്‍മിക്കാം:
```python
>>> [i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
2. ഒന്നു മുതല്‍ 9 വരെയുള്ള ഇരട്ട സംഖ്യകള്‍ അടങ്ങുന്ന ലിസ്റ്റ് നമുക്ക് ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിച്ച് ചുവടെക്കാണുന്ന രീതിയില്‍ നിര്‍മിക്കാം:
```python
>>> [i for i in range(1, 10) if i % 2 == 0]
[2, 4, 6, 8]
```
ഇതേ കാര്യം മറ്റൊരു തരത്തില്‍ ചുവടെക്കാണുന്ന രീതിയില്‍ ചെയ്യാം. പക്ഷേ `condition` എങ്ങനെ ഉപയോഗിക്കാം എന്നു കാട്ടാന്‍ വേണ്ടി മാത്രമാണു ഞാന്‍ മുകളിലെ ഉദാഹരണം എഴുതിയിരിക്കുന്നത്.
```python
>>> [i for i in range(2, 10, 2)]
[2, 4, 6, 8]
```
നിങ്ങള്‍ക്ക് വ്യക്തമായി എന്നു വിശ്വസിക്കട്ടെ.
3. `expression` എന്ന ഒരു ഭാഗം നമ്മള്‍ സിന്റാക്സില്‍ എഴുതിയിട്ടുണ്ടെങ്കിലും ഇതുവരെയുള്ള ഉദാഹരണങ്ങളില്‍ നമ്മള്‍ ഇറ്ററബിള്‍ ഒബ്ജെക്ടിലെ ഐറ്റം തന്നെയാണ് നല്കിയിരുന്നത്. നമുക്ക് ഒരു എക്സ്പ്രെഷന്‍ എഴുതിനോക്കാം. അതിനായി 0 മുതല്‍ 10 വരെയുള്ള സംഖ്യകളുടെ സ്ക്വയര്‍ കാണാനുള്ള ഒരു ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ നമുക്ക് എഴുതാം.
```python
>>> [i ** 2 for i in range(0, 11)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
ഇവിടെ `i ** 2` എന്നുള്ളത് എക്സ്പ്രെഷന്‍ ആണ്.

എവിടെ ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിക്കണം എന്നുള്ളത് സന്ദേഹമുളവാക്കുന്ന ഒരു കാര്യമാണ്. for ലൂപ്പ് ഒഴിവാക്കി കോംപ്രഹെന്‍ഷന്‍ എഴുതാന്‍ കഴിയുന്ന സാഹചര്യങ്ങള്‍ ഉണ്ടെങ്കില്‍ ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ തന്നെ ഉപയോഗിക്കുക. ഉദാഹരണമായി ഒരു ലിസ്റ്റിലേക്ക് 0-മുതല്‍ 10 വരെയുള്ള സംഖ്യകളുടെ സ്ക്വയര്‍ append ചെയ്യണം എന്ന് വിചാരിക്കുക. സാധാരണ ഗതിയില്‍ നിങ്ങള്‍ കാണുക ചുവടെയുള്ള `for` ലൂപ്പ് ഉപയോഗിച്ചുള്ള പ്രോഗ്രാം ആയിരിയ്ക്കും.

```
square = []
for i in range(0, 11):
    sq = i ** 2
    square.append(sq)
print(square)
```
എന്നാല്‍ ഇതേ കാര്യം ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിച്ച് നമുക്ക്:

```
square = [item ** 2 for item in range(0, 11)]
print(square)
```

എന്ന രീതിയില്‍ ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിച്ച് എഴുതാം. 

???+ note
	ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിക്കുമ്പോള്‍ പ്രോഗ്രാമിലെ വരികള്‍ കുറയുക മാത്രം അല്ല. പ്രോഗ്രാമിന്റെ വേഗത കൂടുന്ന എന്ന മെച്ചവും ഉണ്ട്.

#### ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍: നെസ്റ്റഡ് ഫോര്‍ ലൂപ്പ്

ഒന്നിലധികം for ലൂപ്പുകളും കണ്ടീഷനുകളും നമുക്ക് ലിസ്റ്റ് കോംപ്രഹെന്‍ഷനില്‍ എഴുതാവുന്നതാണ്. 2 ലിസ്റ്റുകളിലെ നമ്പറുകളുടെ കോമ്പിനേഷന്‍ ചുവടെ കാണുന്ന രീതിയില്‍ ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്‍ ഉപയോഗിച്ച് കണ്ടെത്താവുന്നതാണ്.

```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

മുകളിലുള്ള പ്രോഗ്രാം ചുവടെയുള്ള പ്രോഗ്രാമിന്റെ ലിസ്റ്റ് കോംപ്രഹെന്‍ഷന്റെ പതിപ്പാണ്.

```python
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```